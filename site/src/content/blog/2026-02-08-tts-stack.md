---
title: "TTS in 2026: the stack from text to waveform (and where it breaks)"
description: "A production-first view of TTS: where failures come from, what to control, and what to measure (with a small real sample)."
pubDate: 2026-02-08
tags: [tts, voice, systems]
icon: "ğŸ”Š"
---

import Tldr from "../../components/Tldr.astro";
import Numbers from "../../components/Numbers.astro";
import Insights from "../../components/Insights.astro";

<Tldr
	items={[
		"TTS fails more often in text normalization + pronunciation than in the vocoder.",
		"Latency consistency matters more than peak quality for voice UX.",
		"Ship with controls (rate/emphasis) + monitoring (dropouts, clipping, pacing).",
	]}
/>

Text-to-speech looks solvedâ€”until you try to ship it.

Modern neural TTS sounds great in demos, but production quality depends on a whole stack:

1. **Text normalization** (numbers, abbreviations, dates)
2. **Pronunciation / phonemization**
3. **Prosody** (durations, stress, intonation)
4. **Acoustic modeling** (text/phonemes â†’ mel or latent)
5. **Vocoder** (mel/latent â†’ waveform)
6. **Streaming + buffering**

Plots generated by:

- `site/analysis/generate_all.py` (task: `tts_durations`)

## A tiny real measurement (duration)

This is a small real sample of TTS outputs (just to force the discipline of measuring):

<Numbers
	rows={[
		["Samples", "4"],
		["Durations (s)", "1.7, 5.2, 8.3, 8.6"],
		["Why it matters", "duration controls pacing + turn-taking"],
	]}
/>

![](/blog/2026-02-08-tts-stack/duration-percentiles-heatmap.svg)

## Where TTS breaks (in real products)

### 1) Text normalization failures

- â€œ1/2â€ â†’ â€œone slash twoâ€ vs â€œone halfâ€
- â€œâ‚¬12.50â€ â†’ wrong currency or decimal reading
- times and dates

If you let the model guess, youâ€™ll ship embarrassing mistakes.

### 2) Pronunciation failures

Names, acronyms, and domain terms need:

- custom lexicons
- grapheme-to-phoneme overrides
- user-specific pronunciation adaptation (if allowed)

### 3) Latency and streaming failures

Voice UX is sensitive to:

- time-to-first-audio
- chunking artifacts
- buffering glitches

A strong TTS model thatâ€™s slow will feel worse than a slightly weaker model thatâ€™s fast and consistent.

<Insights
	title="Minimal production checklist"
	items={[
		"Deterministic text normalization (donâ€™t let the model improvise dates/units).",
		"Configurable pronunciation dictionary for names + domain terms.",
		"Prosody controls (rate/emphasis) exposed as product features.",
		"Streaming path (first chunk fast) + monitoring for audio glitches.",
	]}
/>

## Reproduce

```bash
python site/analysis/generate_all.py
```
